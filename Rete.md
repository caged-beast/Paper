# Rete: A Fast Algorithm for the Many Pattern/Many Object Pattern Match Problem

## 摘要

Rete匹配算法是用来比较大量模式和对象的一种高效算法，被用于（包含几百到一千模式和对象的）产生式系统解释器。本文详细介绍了Rete算法：解释了该算法中的基本概念，描述了该算法中的模式和对象怎么表示以及模式匹配器怎么运行。

## 1. 引言

模式匹配问题是对大量的模式和对象进行比较，确定所有的匹配项。也就是说，模式匹配器要找到匹配每条模式的所有对象。这种模式匹配被广泛用于人工智能。举个例子，它是产生式系统解释器的基础构件。解释器用它来确定哪些产生式的条件部分是满足的。不幸的是，当涉及到大量模式和对象时，模式匹配会变得很慢，一些系统在模式匹配上花的时间超过了九成。本文描述了一种用于模式匹配的高效算法，该算法被设计用于产生式系统解释器，但因为它在其他语言和系统中可能也是有用的，这里详细地介绍该算法。
本文讨论效率的两个互补的方面：1.为该任务设计一个算法，2.在计算机上执行该算法。
第一部分的剩余部分给出一些背景信息。第二部分陈述该算法中的基本概念。第三部分解释模式和对象应该怎么表示才能使算法执行高效。第四部分详细描述了该算法的一个快速实现。最后第五部分给出了该算法的一些分析结果。

### 1.1 OPS5

本文中描述的方法是为产生式系统解释器设计开发的，所以我们用来自产生式系统的例子来对它做说明。本节简单介绍示例中所用的语言，OPS5。
一个产生式系统程序由一组无序的If-Then语句（这些语句被称为产生式）组成。产生式要操作的数据被放在一个叫做工作内存的全局数据库中。习惯上把一个产生式的If部分称作左手部分（LHS），Then部分称作右手部分（RHS）。解释器通过执行以下操作来执行一个产生式系统。

1. 匹配。评估产生式的LHSs，确定在当前工作内存状态下哪些LHS是满足的。
2. 解决冲突。从（LHS是满足的）中选择一条产生式，如果所有的产生式的LHS都不满足，解释器停止。
3. 执行动作。执行刚刚选中的这条产生式的RHS中的动作。
4. 回到步骤1。

OPS5工作内存中通常有几百个对象，每个对象通常有10到100个相关的属性-值对。一个对象和它的属性-值对合成为一个工作内存元素。下面是一个典型的OPS5工作内存元素,它表示该对象是属于Expression类，对象名为Expr17，第一个参数为2，操作符为\*，第二个参数为X
$$(Expression\qquad \uparrow Name\quad Expr17\qquad \uparrow Arg1\quad 2\qquad \uparrow Op\quad *\qquad \uparrow Arg2\quad X)$$
$\uparrow$是OPS5中用来区分属性名和值的操作符。
产生式的LHS由一系列的模式（即一系列对工作内存元素的部分描述）组成。当一个模式P描述一个元素E时，就说模式P匹配元素E。在一些产生式中，一些模式前面带有否定符号\-。一个LHS当满足以下条件时就说它是满足的：
1.所有前面没有否定符号的模式都匹配一个工作内存元素，并且
2.不存在前面带有否定符号的模式匹配一个工作内存元素。
最简单的模式只包含常量符号和数字。
对于一个只包含常量的模式，如果该模式中的每一个常量在一个工作内存元素的对应位置都出现，那么就说该模式匹配该工作内存元素。（因为模式是部分描述，并不要求工作内存元素中的每一个常量都在模式中出现），因此模式
$$(Expression\qquad \uparrow Op\quad*\qquad \uparrow Arg2\quad 0)$$
会匹配元素：
$$(Expression\qquad \uparrow Name\quad Expr86\qquad \uparrow Arg1\quad X\qquad \uparrow Op\quad *\qquad \uparrow Arg2\quad 0)$$
在OPS5中许多非常量符号可用于定义模式，但最重要的两个是变量和谓词。一个变量是以字符<开始，以字符>结束的符号，如\<X>。一个模式中的变量会匹配一个工作内存元素中的任何值，但如果一个变量在某个产生式的LHS中出现了不止一次，那么所有的出现都要匹配相同值。因此模式

$$(Expression\qquad \uparrow Arg1\quad <VAL>\qquad \uparrow  Arg2\quad <VAL>)$$
会匹配以下元素：
$$(Expression\qquad \uparrow Name\quad Expr9\qquad \uparrow Arg1\quad Expr23\qquad \uparrow Op\quad *\qquad \uparrow Arg2\quad Expr23)$$

$$(Expression\qquad \uparrow Name\quad Expr5\qquad \uparrow Arg1\quad 0\qquad \uparrow Op\quad -\qquad \uparrow Arg2\quad Expr0)$$
但不会匹配元素：
$$(Expression\qquad \uparrow Name\quad Expr8\qquad \uparrow Arg1\quad 0\qquad \uparrow Op\quad *\qquad \uparrow Arg2\quad Expr23)$$
OPS5中的谓词包括$=\quad<>\quad<\quad>\quad<=\quad>=$。谓词放在属性名和值之间，表示待匹配的值必须以这种方式和模式中的值相关联。举个例子，
$$(Expression\qquad \uparrow Op\quad <>*)$$
会匹配所有操作符不是\*的表达式。谓词既能用于常量，也能用于变量。举个例子，
$$(Expression\qquad \uparrow  Arg1\quad <LEFT>\qquad \uparrow  Arg2\quad <><LEFT>)$$
会匹配所有第一个参数和第二个参数不同的表达式。
产生式的RHS由一个无条件的动作序列组成。这里只对改变工作内存的动作做介绍。MAKE动作创建一个新元素并把它加入工作内存。MAKE的参数类似于LHSs中的模式。举个例子，
$$(MAKE \quad Expression\qquad \uparrow Name \quad Expr1\qquad \uparrow Arg1\quad 1)$$
将创建一个表达式，该表达式的名字是Expr1，第一个参数是1，其它属性值都是NIL（OPS5中的默认值）。MODIFY动作对一个现存的元素中的一个或多个属性值做改变。该动作以一个模式指示符和一个属性-值列表对作参数。举个例子，动作
$$(MODIFY\quad  2\qquad \uparrow Op\quad NIL\qquad \uparrow Arg2\quad NIL)$$
将使用匹配第二个模式的表达式并把它的操作符和第二个参数改为NIL。REMOVE动作从工作内存中删除元素。该动作以模式指示符作参数。举个例子，
$$(REMOVE\quad 1\quad 2\quad 3)$$
会删除和一个产生式中前三个模式匹配的元素。
一个OPS5产生式由下列部分组成：1.符号P，2.产生式的名字，3.LHS，4.符号-->，5.RHS，并用一组括号把他们括起来。原文中例举了一个典型的产生式。

### 1.2 研究产生式系统的效率

由于执行速度一直是产生式系统的主要问题，一些研究人员一直在研究效率问题。最常见的方法是将索引与对LHS的直接解释相结合。在最简单的索引形式中，解释器通过从每个工作内存元素中提取一个或多个特征来开始匹配过程，并使用这些特征散列到产生式集合中。这样生成一个LHSs可能会满足的产生式集合。解释器将逐个检查该集合中的每个LHS，以确定它是否真的是满足的。一种更高效的索引形式引入了可记忆。一个典型的方案是为每个模式存储一个计数，当系统开始执行时，这些计数都为零。当一个元素进入工作内存，索引函数将这个新元素作为其唯一的输入并执行，所有到达了的模式的计数加一。当一个元素离开工作内存时，索引再次执行，所有到达了的模式的计数减一。解释器只对这些其所有的模式的计数不为零的LHSs执行直接解释步骤。McCracken等人描述过使用该方案（并在某些情况下和其它的效率措施相结合）的解释器。
这里将要描述的模式匹配算法（Rete算法），是一种可以被描述成不需要解释步骤的索引方案。索引函数被表示为一个由简单特征识别器组成的网络。这种表示与所谓结构化模式的图的表示有关。Rete算法于1974年首次提出。1977年的一篇论文描述了一些相当复杂的 特征识别器网络的解释器，包括并行解释器和尽可能延迟模式评估的解释器。1979年的一篇论文讨论了网络的简单但非常快速的解释器。本文主要基于1979年的那篇论文。

## 2. Rete匹配算法——基本概念

在产生式系统解释器中，匹配过程的输出和冲突解决过程的输入是一个称为冲突集的集合。冲突集是一个以下形式的有序对的集合
$$<产生式，由其LHS匹配的元素列表>$$
这些有序对被称为实例。Rete匹配算法式一种计算冲突集的算法，即它是一种把LHSs集合和元素集合进行比较来找到所有实例的算法。该算法能高效的处理大集合因为它不会对集合迭代。

### 2.1 怎么避免对工作内存迭代

模式匹配器可以通过在循环之间存储信息来避免迭代工作内存中的元素。需要迭代的步骤是确定给定的模式是否与某工作内存元素相匹配。最简单的解释器通过逐个将模式与元素进行比较来确定这一点。通过在每个模式中存储一个匹配的元素列表，可以避免迭代。当工作内存改变时更新该列表。当一个元素进入工作内存时，解释器找到所有与之匹配的模式并把该元素加入这些模式的列表。当一个元素离开工作内存时，解释器找到所有与之匹配的模式并把该元素从这些模式的列表中移除。
由于使用Rete算法的模式匹配器保存了这类信息，它们无需检查工作内存。可以把模式匹配器看作一个黑盒子，它有一个输入（工作内存的改变），和一个输出（冲突集的改变）。举个例子，如果这个黑盒子被告知元素
$$(Goal\qquad \uparrow Type\quad Simplify\qquad \uparrow Object\quad Expr19)$$
被添加进工作内存，它可能会响应产生式TimexN刚刚被实例化。(参考原文中的上文)

#### 2.1.1 令牌

传递到黑盒中的工作内存更改的描述称为令牌。一个令牌是一个标签和一个数据元素列表的有序对。在Rete匹配算法最简单的实现中，只需要+和-两个标记。+说明工作内存中加入了新的东西，-说明工作内存中有东西被移除。当一个元素被修改时，会有两个令牌发送到黑盒，一个标记旧元素删除的令牌和一个标记新元素加入的令牌。举个例子，如果
$$(Expression\qquad \uparrow Name\quad Expr41\qquad \uparrow Arg1\quad Y\qquad \uparrow Op\quad +\qquad \uparrow Arg2\quad Y)$$
被改为
$$(Expression\qquad \uparrow Name\quad Expr41\qquad \uparrow Arg1\quad Y\qquad \uparrow Op\quad *\qquad \uparrow Arg2\quad Y)$$
将生成以下两个令牌
$$<-(Expression\qquad \uparrow Name\quad Expr41\qquad \uparrow Arg1\quad Y\qquad \uparrow Op\quad +\qquad \uparrow Arg2\quad Y)>$$

$$<+(Expression\qquad \uparrow Name\quad Expr41\qquad \uparrow Arg1\quad Y\qquad \uparrow Op\quad *\qquad \uparrow Arg2\quad Y)>$$

### 2.2 怎么避免对产生式内存迭代

Rete算法通过使用树型结构的排序网络或产生式的索引来避免对产生式集合进行迭代。黑盒子的主要组件是对模式进行编译而得到的网络。下面的部分将解释如何将模式编译成网络，以及网络如何执行黑盒的功能。

#### 2.2.1 模式的编译

当模式匹配器处理工作内存元素时，它会测试该元素的许多特征。这些特征可以分为两类。第一类可以称为元素内特征，它们只涉及一个工作内存元素。考虑以下模式。
$$(Expression\qquad \uparrow Name\quad <N>\qquad \uparrow Arg1\quad 0\qquad \uparrow Op\quad +\qquad \uparrow Arg2\quad <X>)$$

当模式匹配器处理这个模式时，它试图找到具有以下元素内特征的工作内存元素。

+ 元素的类必须是Expression。
+ Arg1属性的值必须是数字0。
+ Op属性的值必须是原子+。
另一类特征，即元素间特征，是一个变量出现在多个模式中的结果。考虑Plus0x的LHS部分：
$$
\begin{aligned}
& (Goal\qquad \uparrow Type\quad Simplify\qquad \uparrow Object\quad <N>)\\
& (Expression\qquad \uparrow Name\quad <N>\qquad \uparrow Arg1\quad 0\qquad \uparrow Op\quad +\qquad \uparrow Arg2\quad <X>)
\end{aligned}
$$
上面列出了第二个模式的元素内特征。可以为第一个模式构造一个类似的列表。但是除了这两个列表之外，还需要以下元素间特征，因为变量\<N>出现了两次。
+ goal对象的Object的属性值必须和expression对象的Name属性值相等。
模式编译器通过将测试元素特征的节点连接在一起来构建网络。当编译器处理LHS时，它从元素内特征开始。它确定每个模式所需的元素内特性，并为该模式构建线性节点序列。每个节点测试单个特征。在编译器完成对元素内特征的处理之后，它将构建节点来测试元素间特征。每个节点都有两个输入，因此它可以将网络中的两条路径连接成一条。第一个双输入节点连接前两个模式的线性序列，第二个双输入节点连接第一个双输入节点的输出和第三个模式的序列，以此类推。双输入节点对（应用于其处理的元素的）每个元素间特征进行测试。最后，在双输入节点之后，编译器构建一个特殊的终端节点来表示产生式。这个节点连接到最后一个双输入节点。图1（参看原文）展示了Plus0x和相似产生式Time0x的网络。注意，当两个LHS需要相同的节点时，编译器共享部分网络，而不是构建重复的节点。

#### 2.2.2 网络中的处理

网络的根节点(在图1的顶部)是黑盒的输入。该节点接收发送到黑盒的令牌，并将令牌的副本传递给它的所有后续节点。顶部节点的后继节点(执行元素内测试的节点)有一个输入和一个或多个输出。每个节点测试一个特征，并将通过测试的令牌发送给后续节点。双输入节点比较来自不同路径的令牌，如果它们满足LHS的元素间约束，则将它们连接成更大的令牌。由于其他节点执行了测试，终端节点将只接收实例化LHS的令牌。终端节点向黑盒子外发送冲突集必须修改的信息。
作为节点操作的一个例子，考虑当将以下两个元素放入空的工作内存时，图1中的网络会发生什么。
$$
\begin{aligned}
& (Goal\qquad \uparrow Type\quad Simplify\qquad \uparrow Object\quad Expr17)\\
& (Expression\qquad \uparrow Name\quad Expr17\qquad \uparrow Arg1\quad 0\qquad \uparrow Op\quad *\qquad \uparrow Arg2\quad X)
\end{aligned}
$$
首先令牌
$$<+(Goal\qquad \uparrow Type\quad Simplify\qquad \uparrow Object\quad Expr17)>$$
被创建并被发送到网络的根节点。该节点再把该令牌发送给它的后继。其中一个后继(图1中右侧)测试并拒绝它，因为它不是Expression类。此节点不将令牌传递给它的后继。顶部节点的另一个后继节点接受令牌(因为它是Goal类)，并将该令牌发送给它的后继节点。新的节点继续接受令牌(因为它的类型是Simplify)，并将令牌发送给它的后继节点，即双输入节点。由于没有其他令牌到达双输入节点，所以不能执行测试，它们只能存储令牌并等待。
当令牌

$$<+(Expression\qquad \uparrow Name\quad Expr17\qquad \uparrow Arg1\quad 0\qquad \uparrow Op\quad *\qquad \uparrow Arg2\quad X)>$$
被处理时，由单输入节点测试它，并向下传递到Time0x的双输入节点的右输入。此节点将新令牌与之前的令牌进行比较，如果发现它们允许一致地绑定变量，则创建并发送令牌

$$
\begin{aligned}
   <+ & (Goal\qquad \uparrow Type\quad Simplify\qquad \uparrow Object\quad Expr17)\\
   & (Expression\qquad \uparrow Name\quad Expr17\qquad \uparrow Arg1\quad 0\qquad \uparrow Op\quad *\qquad \uparrow Arg2\quad X)>
\end{aligned}
$$
当它的后继节点即Time0x的终端节点接收到这个令牌时，它将Time0x的实例添加到冲突集中。

#### 2.2.3 在网络中保存信息

如上所述，黑盒必须保存状态信息，因为它需要知道工作内存中有什么。在简单的Rete网络中，所有这些状态都由双输入节点存储。每个双输入节点包含两个称为左右内存的列表。左内存保存到达其左输入的令牌的副本，而右内存保存到达其右输入的令牌的副本。只要令牌还有用，它们就会被保存。下一节将解释节点如何确定令牌什么时候不再有用。

#### 2.2.4 使用标签

令牌中的标签指示在处理令牌时如何更改状态信息。+和-标签的处理是相同的，除了以下几点:

+ 终端节点使用标签来决定是向冲突集中添加实例，还是删除现有的实例。当处理+令牌时，添加一个实例;当处理-令牌时，实例被移除。
+ 双输入节点使用标签来决定如何修改它们的内部存储器。当处理+令牌时，它被存储在内部内存中;处理—令牌时，删除带有相同数据部分的令牌。
+ 双输入节点使用标签来确定它们自身构建的令牌用什么标签。在创建新输出时，将为它提供刚刚到达双输入节点的令牌的标签。

### 2.3 使节点类型集合完整

图1中的网络包含四种节点:根节点、终端节点、单输入节点和双输入节点。当然，可以定义更多类型的节点，但要获得一个完整而有用的集合，只需要再多一些即可。事实上，解释OPS5只需要再加另外两种节点。
对于否定模式(即前面有-的模式)，需要第二种双输入节点。这种新的双输入节点在其左侧内存中为每个令牌存储一个计数。该计数指明的是右侧内存中允许一致变量绑定的令牌数量。其右侧内存中的令牌包含匹配否定模式的元素——或者，更准确地说，令牌包含具有否定模式所需的元素内部特征的元素。该节点允许计数为0的令牌通过。
需要定义的最后一种节点类型是前面描述的单输入节点的变体。这种节点测试工作内存元素的常量特征(例如，测试一个值是否等于给定的原子符号)。这种新的单输入节点比较来自工作内存元素中的两个值，用于处理一个变量出现两次或多次的模式。例如，下面这个模式就需要一个这种节点，因为变量\<X>出现了两次。
$$(Expression\qquad \uparrow Arg1\quad <X>\qquad \uparrow Op\quad +\qquad \uparrow Arg2\quad <X>)$$

## 3. 表示网络和令牌

本节描述令牌和节点的表示，这使得我们能编写非常快速的解释器。

### 3.1 工作内存元素

选择工作内存元素怎么表示时应该考虑两点：

1. 该表示应该使得从元素中提取值是容易的，因为每个测试都涉及提取一个或多个值。
2. 一旦值可用，表示应该使得执行测试是容易的。
为了便于提取值，每个元素都应该存储在内存中的连续块中，每个属性都应该在块中有指定的索引。例如，如果类为Ck的元素有17个属性(从A1到A17)，它们应该存储为由18个值组成的块。第一个值将是类名(Ck)。第二个值是属性A1的值。第三个是属性A2的值，等等。给属性的索引赋什么值并不重要;重要的是每个属性都有一个固定的索引，并且索引是在编译时赋值的。这允许编译器将索引构建到节点中。从而。像下面这样的节点:
$$Status属性的值是否为Pending?$$
就可以构建成:
$$位置8的值是否为Pending?$$
使用这种表示方式，可以在一个内存引用中访问每个值，而不管元素拥有多少个属性。
为了降低测试的成本，表示应该具有显式的类型位。表示值的一种常见方法是使用一个字表示类型，使用一个或多个字表示值本身。但是更节省空间的表示也是可能的。例如，考虑一种支持三种数据类型(整数、浮点数和原子)的产生式系统语言。可能会使用如下的表示:为每个值分配一个字。对于整数和原子，低阶的16位(比方说)将保存数据，而第十七位将是一个类型位。对于浮点数，整个字将用来存储一个规范化的浮点数。一个浮点数可以通过在高阶位中至少有一个非零位来识别。

### 3.2 网络

本节解释如何以类似于冯诺依曼机器指令的形式表示节点。之所以选择这种表示是因为它允许像传统的冯诺伊曼体系结构的解释器那样组织网络解释器。

#### 3.2.1 汇编语言符号

为了便于讨论节点的表示，下面使用了一种汇编语言符号。如下的单输入节点
$$位置8的值是否为Pending?$$
表示为
$$TEQA\;8,Pending$$
T表示测试，说明这是一个单输入节点。EQ表示它是一个相等性测试(还需要有NE表示不相等，LT表示小于，等等)。A表示该节点测试的是原子类型的数据。(还需要有一个类型N表示整数值，一个类型F表示浮点数，一个类型S用于比较同一个工作内存元素中的两个值)。
下面是一个双输入节点的示例：
$$L001\quad AND\;(2)=(1)$$
L001是一个标签。AND表示这是一个用于非否定模式的双输入节点。序列(2)=(1)表示该节点比较左边的第二个元素值和右边的第一个元素值;=表示它执行相等性测试。
终端节点包含类型TERM和产生式名。例如
$$TERM\quad Plus0X$$
后面会解释，该表示中不需要根节点。

#### 3.3.2 线性化网络

为了使节点与冯诺伊曼机的指令相似，必须消除节点之间的显式链接。许多显式链接可以简单地通过线性化网络来消除，即将一个节点和它的后继节点放置在连续的内存位置。然而，由于一些节点有多个后继节点，还有一些节点(双输入节点)有多个前驱节点，线性化本身是不够的:必须定义两种新的节点类型来替换一些链接。新节点中的第一个，即FORK，用于指示一个节点有多个后继节点。其中FORK节点包含多个后继节点中的一个节点的地址。另一个后继节点紧跟在FORK之后。例如，下面的FORK表示节点L003有两个后继节点
$$
\begin{aligned}
   L003\quad & TEQA\;0,Expression\\
   & FORK L004\\
   & TEQA\;3,+\\
   & ...\\
   L004\quad & TEQA\;3,*\\
\end{aligned}
$$
另一种新的节点类型是MERGE，它用于网络必须重新生长在一起的地方——也就是说，在双输入节点之前。双输入节点被放置在它的一个前驱节点(比如它的左前驱节点)之后，而MERGE被放置在另一个前驱节点之后。MERGE包含双输入节点的地址，其功能非常类似于无条件跳转。线性化过程的效果如图2所示，它包含了图1的产生式和它们的LHS的线性化网络。（图2参见原文）

#### 3.2.3 内存中节点的表示

本节展示如何在32位字长计算机上表示节点。之所以选择32位的字长，是因为它是现在最常见的。其实字长具体是多少并不重要。由于网络可以在FORK处建立根结点(见图2中的例子)，因此没有必要为网络建立显式的根结点。因此只需要7类节点，即FORKs、MERGEs、两种类型的单输入节点、两种类型的双输入节点以及终端节点。
FORKs和MERGEs可以用单个字表示。其中6位作为类型字段(该字段表明该字表示的是什么)，其余26位可以用于保存所指节点的地址。
两种类型的单输入节点都可以表示为单个字，这个字分为三个字段。第一个字段将保存节点的类型。第二个字段将保存要测试的值的索引。第三个字段将保存一个常量或第二个索引。一个字中的位可以按如下方式分配。（参见原文）
要表示整数或原子，需要使用3.1节的16位字段格式。由于浮点数不能用16位表示，在测试浮点数的节点中，这个字段将保存的不是浮点数，而是浮点数的地址。
终端节点也可以存储为单个字。它包含两个字段，一个类型字段，加上一个用于表示产生式的索引或地址的较长的字段。
双输入节点的长度取决于该节点测试的值对的数量。每个节点可以有一个基本信息的字，加上一个每个值对的字。第一个字将包含一个类型字段、一个指向左侧输入的内存的指针、一个指向右侧输入的内存的指针，以及一个指明节点执行了多少测试的字段。字中的位可以按如下方式分配。（参见原文）
每个测试的字包含三个字段。其中两个字段用于保存要测试的两个元素的索引。剩下的字段将表示要执行的测试，也就是说，它将指明节点是要测试两个元素是否相等、是否不等，还是其他类型。字中的位可以按如下方式分配。
注意，这里的索引字段比单输入节点中的索引字段要长。这是必要的，因为双输入节点中的索引必须指定标记中的元素和元素中的值。

### 3.3 令牌

本节描述了令牌的一种空间高效的表示方法。这种表示并不适合所有的解释器，它要求解释器每次只处理一个工作内存变化，并且要求首先深度遍历网络的某些部分。幸运的是，这些都不是严格的限制。执行匹配的最简单方法是一次处理一个令牌，首先遍历整个网络深度。第4节描述了一种以这种方式运行的解释器。
如果解释器以这种方式运行，那么可以使用一个栈来表示它的令牌。当要构建令牌时，首先将令牌的标签入栈，然后按顺序将工作内存元素入栈。当需要扩展令牌时(一种非常常见的操作——请参阅第4节中的代码)，额外的工作内存元素将被入栈。
如果单输入节点不使用这个栈，那么它们的效率会更高。由于所有的单输入节点都将处理相同的工作内存元素——刚添加到工作内存或从工作内存中删除的元素——因此该元素应该要很容易就能取到。可以将元素复制到内存中的专用位置，也可以将元素的地址加载到专用的基寄存器中。这两种方法都可以让单输入节点访问元素，而无需遍历栈。

### 3.4 解释器状态

除了用于令牌的栈外，解释器还必须为其状态信息维护另一个栈。使用栈的一个原因是允许解释器在网络中找到自己的路径。当解释器传递一个FORK时，它将它没有跟踪的指针入栈。然后，当它到达一条路径的末尾时，它从栈中弹出一个指针，并跟踪它。使用栈的另一个原因是为双输入节点提供一个位置来保存它们的局部信息。在下一节中可以看到，在处理双输入节点的后继节点时，有时必须暂停它自身。栈保存恢复处理双输入节点所需的信息。

## 4. 网络解释器

本节介绍一个网络解释器执行的具体操作。从每个类中选择一个节点，并编写了解释节点的代码。需要注意的是，由于代码序列短而简单，因此可以很容易地用微代码来编写它们。
代码是用类似PASCAL的语言编写的，具有文字标签和字段提取。字段提取是通过将两个数字放在尖括号中来表示的，第一个数字是字段中高阶位的索引，第二个数字是低阶位的索引。假设这些位从右到左编号，低阶位为位零。因此表达式SELF<31:26>表示将提取变量SELF值的高6位并右对齐。
解释器的主循环非常简单:解释器从内存中获取下一个节点，并根据其类型字段进行调度。将存放节点的内存段称为NODE_MEMORY，将指向当前节点的指针称为NC。主循环如下:
$$
\begin{aligned}
MAIN:\quad SE & LF:=NODE\_MEMORY[NC];\quad !高6位为类型字段\\
CA & SE \;\;SELF<31:26> OF\\
& 0: GOTO \;\; FORK; \\
& 1: GOTO \;\; MERGE; \\
& 2: GOTO \;\; TERM; \\
& 3: GOTO \;\; TEQA; \\
& ... \\
& END;\\
\end{aligned}
$$
节点被复制到变量SELF中，以便节点程序可以检查它。为各种节点类型分配的数字是任意的。使用Goto而不是过程调用，因为这些例子使得解释器的所有状态都是显式的，而不是隐藏在PASCAL的栈中。
TEQA是典型的测试常数的单输入节点。如果正在被处理的工作内存元素是保存在被称为CURRENT的内存段中，那么TEQA如下所示。
$$
\begin{aligned}
TEQA:\quad & TEMP := CURRENT[SELF<25:16>]: \quad !获取索引字段指向的字\\
   & IF\;(TEMP<31:16>=0)\;AND\quad !测试类型位\\
   & \quad(TEMP<15:0>=SELF<15:0>)\quad !测试值\\
   & THEN\; GOTO\; SUCC\\
   & ELSE\; GOTO\; FAIL:\\
\end{aligned}
$$
在每个单输入节点之后执行SUCC或FAIL。当测试成功时执行SUCC，当测试失败时执行FAIL。SUCC增加节点计数器以指向下一个节点。
$$
\begin{aligned}
SUCC:\quad & NC:=NC+1;\\
   & GOTO\;MAIN;
\end{aligned}
$$
FAIL试图从未处理节点的栈中获得一个节点;如果不能，它就停止匹配。假设栈名为NS，指向栈顶的指针名为NSTOP，代码如下:
$$
\begin{aligned}
FAIL:\quad & IF\; NSTOP<0\; THEN\; GOTO\; EXIT\_MATCH;\\
   & NC := NS[NSTOP];\\
   & NSTOP := NSTOP - 1;\\
   & GOTO\; MAIN;\\
\end{aligned}
$$
用于比较值对的单输入节点与其他单输入节点类似。TEQS是这些节点的典型代表。
$$
\begin{aligned}
TEQS:\quad & IF\; CURRENT[SELF<25:16>] = CURRENT[SELF<9:0>]\\
   & THEN\; GOTO\; SUCC\\
   & ELSE\; GOTO\; FAIL;\\
\end{aligned}
$$
FORK将一个地址入栈到NS上，然后将控制权传递给下面的节点。
$$
\begin{aligned}
FORK:\quad & NSTOP:=NSTOP+1;\\
   & NS[NSTOP]:=SELF<25:0>;\\
   & GOTO\; SUCC;\\
\end{aligned}
$$
双输入节点必须能够确定它是通过其左输入还是右输入到达的。这可以通过一个全局变量来指明，该变量的值通常为LEFT，但当MERGE将控制传递给一个双输入节点时，该全局变量临时设置为RIGHT。如果这个全局变量名为DIRECTION，则MERGE的代码为
$$
\begin{aligned}
MERGE:\quad & DIRECTION:=RIGHT;\\
   & NC:=SELF<25:0>;\\
   & GOTO\; MAIN;\\
\end{aligned}
$$
两种双输入节点非常相似，所以这里只给出了AND。为了不掩盖重要信息，程序的一些细节被省略了。代码没有显示如何测试变量，也没有显示如何将令牌添加到节点的内存中或从节点的内存中删除令牌。假设令牌栈称为TS，指向顶部元素的指针称为TSTOP，程序如下所示。（参看原文）
最后介绍TERM节点。由于更新冲突集是一个依赖于语言的操作，因此无法给出TERM节点的细节。节点的其余处理如下所示。
$$
\begin{aligned}
TERM:\quad &UPDATE\_CONFLICT\_SET(SELF<25:0>); \\
   & GOTO\; FAIL;\\
\end{aligned}
$$

## 5. 算法的执行

我们对Rete匹配算法的有效性进行了广泛的研究。分析研究(确定了算法的时间和空间复杂度)和实证研究都进行了。本节介绍一些分析研究的结果。由于空间的限制，不可能给出实证结果或分析结果的证明。
表1总结了该算法的分析研究结果。表1中使用了表示渐近复杂度的常用符号。花销为O(f(x))表明花销随着f(x)加上x中的一些较小的项而变化，较小的项被忽略，因为当x很大时，f(x)项占主导地位。花销为O(1)表示花销不受考虑因素的影响。需要指出的是，表1中所有的复杂性结果变动很大，实现边界性能的产生式系统在其它论文中描述。（参见原文）

## 6. 结论

Rete 匹配算法是一种将一组模式与一组对象进行比较，以确定所有可能匹配的方法。这篇文章详细描述了它，因为自1974年以来已经积累了足够的证据，表明它是一个有很多潜在应用的高效算法。
该算法即使在处理大型模式和对象集时也是有效的，因为它没有遍历集合。在这个算法中，模式被编译成一个程序来执行匹配过程。程序不需要遍历这些模式，因为它包含了一个树状结构的排序网络或模式索引。它不需要遍历数据，因为它维护状态信息:程序在进入数据内存时为每个对象计算匹配和部分匹配，并且只要对象还在内存中，它就保存信息。
尽管Rete算法是为产生式系统解释器而开发的，但它也可以用于其他目的。如果产生式系统的模式匹配有什么不寻常的地方，那就是要进行的模式匹配的规模巨大。产生式系统包含相当的模式和数据对象很普通，但它们数量巨大，并且在执行过程中频繁地调用模式匹配器。如果其他类型的程序开始大量使用模式匹配，它们可能会有与产生式系统相同的效率问题，并且可能有必要在它们的解释器中使用类似于Rete匹配算法的方法。当然，不是所有的匹配问题都适合用Rete算法，只有在满足以下三个条件时才行。

1. 模式必须是可编译的。必须能够检查它们并确定一个特征列表，就像2.2.1节中的列表一样。
2. 对象必须是常量。它们不能像模式那样包含变量或其它非常量。
3. 对象集的变化必须相对缓慢。由于该算法在循环之间保持状态，因此在每次循环中大部分数据都发生变化的情况下效率很低。