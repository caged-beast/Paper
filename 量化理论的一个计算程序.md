# 量化理论的一个计算程序

​ 在形式逻辑中用数学方法会得到获得数学定理的纯计算方法，这一想法可以追溯到Leibniz，在世纪之交被Peano重提，在19世纪20年代引起了Hilbert学派的关注。Hilbert强调所有的经典数学都可以用量化理论（*即一阶逻辑*）形式化，所以找到一个算法来确定一个给定的一阶逻辑公式是否永真是数理逻辑的中心问题。然而，Church和Truing证明了这样一个算法并不存在（*1936年*）。这使得当时的人们对于使用现代电子计算机来解决重大数学问题普遍持悲观态度。然而，最近人们对这一问题的兴趣重燃。特别的，人们普遍意识到，虽然对于量化理论来说不存在决定程序，但有很多证明程序是可用的（对于永真的一阶逻辑公式，程序最终会给出一个证明；但对于一个非永真的公式，程序常常陷入寻找证明的死胡同），而且在现代计算机上使用一些这种证明程序是可行的。

​ 通过在量化理论中使用证明程序，Hao Wang和P. G. Gilmore分别得出了他们的程序。Gilmore的程序采用了Herbrand提出的数理逻辑的一个基本定理的一种形式，Wang采用了一个和Gentzen研究相关的量化理论的一个公式。然而，除了最简单的一阶逻辑公式，他们的程序在进行逻辑演算时都遭遇了巨大困难。Wang的程序因为使用的是Gentzen-like的方法，要对真值函数连接词的总数求幂。Gilmore的程序因为使用的是范式，要对现有子句的数量求幂。这两种方法在许多情况下都优于真值表法（因为真值表法要对现有变量的总数求幂），都做出了重要贡献，但也都在处理一些相当简单的例子时陷入困境。

​ 本论文给出了量化理论的一个统一的证明程序，它可以处理一些相当复杂的公式并且一般不会导致求幂。该程序较于之前的程序的优越性可以从下面这个事实看出个大概：一个公式在Gilmore的例程下在IBM 704机器上跑了21分钟也没有得到结果，但是用我们提出的方法，在30分钟之内成功手算得出了结果。（*具体参考下文 6*）

​ 在使用量化理论的证明程序来获得“真正的”数学的定理的证明之前，必须对不同的数学分支做“简短”的公理化。本文不对这一问题做进一步讨论，参考Davis和Putnam的论文，它针对初等数论给出了该问题的一个解决方案。

## 1.一般说明

​ 我们将要描述一个计算程序或算法，当它应用于一个（用下面描述的符号编写的）永真的公式时，它一定会停止并给出该公式永真的一个证明；而对于一个非永真的公式，它会无限期地执行下去而得不到结果。[^1]

​ 我们用来构造公式的符号可以分为几类：标点符号、逻辑符号、（单个）变量、谓词符号、函数符号。

- 标点符号：， （ ）
- 逻辑符号： ~ &  V → ⇿

- 变量：（无穷序列的项）x~1~ x~2~ x~3~ x~4~ ...
- 谓词符号：F G H （可能带有下标）
- 函数符号[^2]：（无穷序列的项）f~1~ f~2~ f~3~ f~4~ ...

​ 我们把可以用这些符号组成的表达式分为三类：项、原子公式、良序公式（缩写为w.f.f）。

​ 下面递归地给出**项的概念**：

1. 表达式 f~i~ 和 x~i~ 是项，其中 i = 1，2，3 ...
2. 如果 p~1~ , p~2~, ... , p~n~ 是项[^3]，那么f~i~(p~1~ , p~2~, ... , p~n~)也是项，p~1~ , p~2~, ... , p~n~叫做f~i~的参数
3. 项只能由1和2生成

​ 下面给出**原子公式的概念**：

​ 如果p是谓词，p~1~ , p~2~, ... , p~n~ 是项，那么p(p~1~ , p~2~, ... , p~n~)是原子公式，其中p~1~ , p~2~, ... , p~n~叫做p的参数。

​ 下面给出**良序公式的概念**：

1. 一个原子公式是一个w.f.f
2. 如果R是一个w.f.f ,那么 ~R, (x~i~)R, (Ex~i~)R 也是 w.f.f
3. 如果R和S都是w.f.f ,那么(R & S), (R V S), (R → S), (R ⇿ S)也是

​ 我们引入下列缩写约定：

- a 代表 f~1~
- f 代表 f~2~
- 如果p是一个函数符号而q是一个项，则pq 代表 p(q)
- 如果p是一个谓词符号，p~1~ , p~2~, ... , p~n~是项，则$ \bar{p}(p_1,p_2, ... ,p_n)$代表~ (p~1~ , p~2~, ... , p~n~)

​ 如果一个w.f.f R中的一个X~i~ 的出现是以(x~i~)P, (Ex~i~)P的形式出现在在R的w.f. 部分，则它是一个约束的出现。如果一个X~i~ 的出现不是约束的，把它称作自由的出现。如果在R中X~i~ 有至少一个自由的出现，那么在R中它是自由的。

​ 如果x~i1~ , x~i2~, ... , x~in~ 是R中的所有自由变量，我们有时会把R写作R(x~i1~ , x~i2~, ... , x~in~)。如果p~1~ , p~2~, ... , p~n~是项，在R中所有x~ik~ 的自由出现处，我们用R(p~1~ , p~2~, ... , p~n~)来表示用p~k~ 替换x~ik~ 的结果，其中i =1，2，... ，n。

​ 在不引起歧义的情况下，括号会被省略。

​ 我们的下一步是从w.f.f类中挑选出逻辑上永真的表达式。这可以通过指定公理和推导规则或参考w.f.f的“解释”来得到，而由Godel[^4]的一个基本结论可知，这些程序得出的公式是相同的。对我们当前的目的而言，最方便的是使用采用“解释”的后一种方式。

​ 一公式R的一个解释由以下两部分组成：一个称作域的元素的非空集合U，对每个函数符号和谓词符号的一组赋值：

- 对于每个在R中出现的带n个参数的函数符号[^5]，我们用一个值在U内的带n个变量的函数对它赋值（其中变量也在U的范围内）。[^6]
- 对于每个在R中出现的带n个参数的谓词符号，我们用一个值为0或1的带n个变量的函数对它赋值（其中变量在U的范围内）。[^7]

​ 设R(x~n1~ , x~n2~, ... , x~nk~)为一个w.f.f。对于R在域U上的一个解释，对U上元素的每个有序k元组(t~1~ , t~2~, ... , t~k~)，为 R(t~1~ , t~2~, ... , t~k~)赋值0或1。对于 ~ &  V → ⇿ 使用常见的真值表，(x~i~)P(x~i~)为0除非对于U中所有的t有P(t)的值为1, (Ex~i~)R为1除非对于U中所有的t有P(t)的值为0。

​ 一个w.f.f. R，如果对于U中的参数的所有集合，在任何解释下R都被赋值1，那么称R是永真的。

​ 一个w.f.f. R，如果对于U中的某些参数选择，存在使得R被赋值1的解释，那么称R是一致的（或可满足的）。否则称R是不一致的。

​ 我们会用到以下事实：

- R是永真的当且仅当~R是不一致的。

​  也就是说，可以通过“反驳”~R来“证明”R，事实上我们对永真性的证明程序会用一个反驳程序的形式来表述。

- 如果w.f.f. (R ⇿ S) 是永真的，那么称R和S逻辑等价。
- 如果一w.f.f. 不包含(x~i~)或(Ex~i~)，称它是无量词的。如果一w.f.f.以一量词(x~i~)和(Ex~i~)的序列开始（其中所有变量出现不超过一次）（*前缀*），并接着一个无量词的w.f.f.（*母体*），那么称该w.f.f.是前束式，或前束范式。一个前束范式的例子是  ( x~1~ )( Ex~3~ )( x~7~ )( Ex~2~ ) F( f(x~3~) , f~3~(x~1~,x~2~) , x~5~ )。如果S是一个和R等价的前束范式，那么称S是R的一个前束范式。给定一个w.f.f.，有一种简单的算法来得到它的前束范式。因此我们的反驳程序只要考虑前束范式就够了。
- R~1~ , R~2~, ... , R~n~的析取是w.f.f. R~1~ V R~2~ V ...  V R~n~，它们的合取是R & R~2~ & ...  & R~n~。如果一w.f.f.是一个原子公式或者其否定，则它是一个文字。一个子句是指一个析取R~1~ V R~2~ V ...  V R~n~，其中每个R~i~是一个文字，并且没有原子公式会出现两次。（如 F(x~1~ V $\bar{G}$(x~2~,x~3~)  是一个字句，但 F(x~1~) V $\bar{F}$(x~1~) 不是。）
- 字句的合取称作合取范式。如果合取范式A逻辑等价于B，那么称A是B的一个合取范式。

​  关于合取范式的进一步讨论可以参考Hilbert 和Ackermann 的论文。实际上，存在一个简单的算法，对于任意非永真的无量词公式都可以得到它的一个合取范式，而对于永真的公式该算法会给出其永真的结论。因此，我们可以假设提供给反驳程序的w.f.f. 是一个前束范式，其母体是一个合取范式。后面我们会看到为什么这是一个有用且实用的假设。

## 2.用函数符号替换存在量词

​ 将要提出的反驳算法会用到下述思想（这本质上可以追溯到 Lowenheim）：可以用函数符号来替换前束范式中的存在量词而不改变其一致性。给出一个例子来说明这一想法：假设给定一个前束范式

​            ( x~1~ )( Ex~2~ )( Ex~3~ )( x~4~ ) ( Ex~5~ )R(x~1~，x~2~，x~3~，x~4~， x~5~ )                                 (i)

其中，矩阵R(x~1~，x~2~，x~3~，x~4~， x~5~ )是无量词的且只包含所示自由变量。考虑另一个公式

​            ( x~1~ )( x~4~ )R(x~1~，f~2~(x~1~)，f~3~(x~1~)，x~4~， f~5~(x~1~,x~4~) )                                 (ii)

只有当公式(ii)是一致的时，公式(i)才是一致的。为了验证这一点，注意(ii)逻辑蕴含(i)，所以如果(ii)是一致的，则(i)也是。另一方面，如果在一些域U下（在对R中谓词字母的某种解释之下）(i)是真的，那么在对R中谓词字母进行相同的解释时，存在U上的函数[^8]f~2~，f~3~，f~5~使得(ii)是真的。因此如果(i)是真的，那么(ii)也是。

​ 因此，在本文中，“用函数符号替换F中的存在量词”（其中F是一个前束范式）将有以下含义：设F前缀中的变量（按出现次序）为x~1~，x~2~，...， x~N~，前缀中的存在量化的变量为x~i1~，x~i2~，...， x~iM~。那么，(1)从前缀中删除量词 (E~Xij~)（j = 1,2, ... ,M）,(2)母体中每个x~ij~的出现都被替换成项f~ij~ (x~q1~，x~q2~，...， x~qp~)的出现，其中(x~q1~)，(x~q2~)，...， (x~qp~)是F的前缀中在(E~Xij~)之前的所有全称量词。

​ 就像刚刚解释过的一样，在上面的例子中“用函数符号替换(i)中的存在量词”将会导致公式(ii)。最后，（回想一下，我们把无参函数符号简单地理解为独立的常量）用函数符号替换

​                 ( Ex~1~ )( x~2~ )( Ex~3~ )( x~4~ ) M(x~1~，x~2~，x~3~，x~4~ )

中的存在量词会得到

​                ( x~2~ )( x~4~ ) M(f~1~，x~2~，f~3~(x~2~)，x~4~ ) 。

## 3.无量词行的序列

​ 我们整个的反驳算法“看”的方式现在可以用一个一般化的方式表示了。假设给定的公式为

​                ( x~1~ )( Ex~2~ )( x~3~ )R(x~1~，x~2~，x~3~ ) ，

其中R是无量词的且只包含所示变量。那么第一步是用函数符号替换存在量词，这将得到

​                ( x~1~ )( x~3~ )R(x~1~，f(x~1~)，x~3~ ) ，

（回想一下，f是f~2~的缩写，a是f~1~的缩写）。接下来我们将生成一个无量词行的序列，如下所示（为简洁起见省略了某些括号）：见原文。注意x~1~，x~3~以所有可能的方式被替换为来自序列 a ,fa ,ffa , ...的项。

​ 当这些无量词生成时，我们将测试前n行的合取的一致性（用接下来这小节描述的方法）。如果对于任意的n，前n行的合取是都是不一致的，那么公式 ( x~1~ )( x~3~ )R(x~1~，f(x~1~)，x~3~ ) 是不一致的（因为这表示所有的无量词行），所以给定的公式也是不一致的。另一方面，如果对于任意的n，前n行的合取是都是一致的，那么该算法永远不会停止，给定的公式是一致的。[^9]

​ 现在给出生成无量词行的序列的一般规则。设F是用函数符号替换存在量词之后的给定公式，f~i1~，f~i2~，...， f~iM~是F中的所有函数符号，f~ik~是一个n~k~元的函数符号(k = 1,2, ... ,M)，D是如下集合：包含单个常数a的最小集合且有性质：每当它包含t~1~，t~2~，...， t~nk~，那么它必包含f~ik~(t~1~，t~2~，...， t~nk~),  L为F中的全称量词个数，S是D中成员的所有有序（按字典顺序）L-元组的序列。[^10]那么第n个无量词行是用t~n1~替换[^11]F中第一个全称量词变量，t~n2~替换F中第二个全称量词变量，...，t~nL~替换F中第L个全称量词变量后的结果，其中t~n1~，t~n2~，...，t~nL~是序列S中的第n个L-元组。

​ 说明：

- 如果愿意，可以以某种方便的方案来用字母作为集合D中表达式的缩写。如果采用了这一原则，上文中的无量词行也许会长这样：见原文。

  从手工计算的角度看，这种数字缩写方案是非常值得的（因为它缩短了公式的长度）。另一方面，如果要用计算机对这一算法进行编程，那么采用这种方案没有什么好处。

- 不是对n =1,2,3, ... 连续测试前n个无量词行的合取的一致性，而是“间断地”测试，比如当n =10,20,30, ... 。如果我们描述的算法确实是要在计算机上进行编程的话，那么应该对把这种“间断性”运用到一致性测试上的相对优势和劣势进行研究。

## 4.命题演算中的可行方法

​ 前面小节中所描述的反驳算法的思想并不新奇。本质上，它可以追溯到Herbrand，我们给出的方案（先生成一个无量词行的序列，然后对 n=1，2，3，... 测试前n行的合取的一致性）此前就有Quine，Gilmore 等人提出过。然而在这方面受关注很少的一个关键难点是，当n很大时找到一个可行的技术来测试前n行的合取的一致性。Quine的“统一证明程序”是用手工计算来描述的，因此他局限于用真值表来进行命题演算。然而，当有k个命题变量的时候，真值表的行数是2^k^，所以真值表的方法很快就不可行了。Gilmore的程序是吧前n行的合取转化为析取范式，但这也会导致求幂（根据给定公式的母体中的子句数量），所以该方法在一般情况下也是不可行的（尽管在特殊情况下，偶然地消去也许会使得公式减少到可处理的长度）。Wang提出了另一种程序。比较起来，Wang的程序不如我们的简单因为他没有用前束范式，他的例程使用使用了一种“Gentzen型”的形式系统，该系统中的证明是“树”型结构（不同于通常所用的“线性”结构），在任一行都可能有分支。就命题演算而言，Wang的技术难点在于分支数量随着逻辑连接词的数量呈指数级增长。因此，当n值很大时（比如n>10）要测试我们的无量词行序列中的前n行的合取的一致性时，我们刚刚描述的三种方法（真值表、析取范式、Gentzen型系统）中没有一种是令人满意的。

​ 相比之下，我们将要描述的方法总是在最多2(R-1)步之内终止，其中R是变量个数（即步骤数随着变量数是线性增长的，而不是指数级）。此外，这个过程中很少会出现比实践中可能出现的例子中的最开始的那个公式还要复杂更多的公式。实际上用这种方法甚至可以用手算解决相当复杂的公式。

​ 我们将要描述的方法依赖于把前n行的合取转化为合取范式。因为这一步骤本身并不能让人分辨出某公式是否是一致的，所以有必要对我们的这一选择做一两点说明。简单来说，理由如下：尽管在某些情况下，范式可能会被用作决策方法（比如把某公式转化为析取范式会自动显示该公式是否是不一致的），它们也有另一个作用，正如术语“范式”所示，使用范式可以使公式规范化，降低结构复杂性。例如，每个合取范式F有结构 A & B & R，其中A是包含一个给定原子公式（比如 p）的子句的合取，B是包含刚刚公式的否定（比如 $\bar{p}$）的子句的合取，R是剩余子句的合取。而且可以证明，F是不一致的当且仅当 A' & R 和 B' & R 都是不一致的，其中A'是由A通过删去p的出现得到的，B'是由B通过删去$\bar{p}$的出现得到的。对于不属于范式的任意公式，很难会有这种规则。

​ 如上所述，我们的问题是要怎么处理当无量词行的数量太大时把整个行系统放入析取范式不可行的情况。在这种情况下，还有一种范式可用，即合取范式。

​ 我们可以使用合取范式源于以下观点：要把整个公式系统放入合取范式，我们只需要把单个公式都放入合取范式即可。因此，就算一个系统有成百上千条公式，它们也可以“一片一片”地被放入合取范式，这中间没有任何“乘法”。即使对手工计算而言，这也是一项可行的（尽管很费力）的工作：因此除了假设系统中的单个公式都是“可处理的”（即公式足够短，可以手工放入合取范式），以及整个系统可以由人写下以外，没有引入任何专业化。

​ 与在一般情况下对某些“大”公式系统的一致性进行测试相比，我们的“无量词行序列”的情况更令人欣喜：也就是说，只要把给定公式的母体（在用函数符号替换存在量词后）放入合取范式，就会自动生成“无量词行”。

​ 在陈述我们对前n个无量词行的合取的一致性的测试时，我们将假设给定的公式的母体是合取范式（因此前n行的合取同样自动地成为合取范式），我们会把整个合取称作一个单一的公式F。

​ 我们的方法由以下三条规则组成，其中 p,q,r,s 是原子公式：

[^1]:因为Church和Turing的结果表明所涉及的公式集是一个递归的可枚举集合，而这个集合本身是不可递归的。所以这里提出的这种算法是最理想的算法。
[^2]:我们使用的函数符号不仅可以用来表示带参数的函数，也可以表示变量，后者可视为无参数的函数。
[^3]: 注意这里的p~1~ , p~2~等符号是作为“语法变量”出现的，即它们代表的是由我们的符号组成的表达式。
[^4]: Godel的完备性定理。
[^5]:如果n = 0，f~i~被赋值U中的一个元素。
[^6]:注意如果出现在R中的f~i~ 既有带m个参数的也有带n个参数的，其中m$\neq$n,要对每个情况赋予不同的函数。在下面的示例中，我们不考虑这中情况。（当然，出现在R中的带相同个参数的f~i~，对其赋相同值）
[^7]:脚注6中对函数符号的说明对这里的谓词符号也适用。

[^8]:这里默认使用了一个非构造性原则即选择公理。或者，也可以使用以下定理：如果(i)是一致的，那么在某个可数的域U中有一个使其为真的解释（Skolem-Lowenheim定理），然后按照U中元素的某一固定顺序明确定义f~2~，f~3~，f~5~。
[^9]:这一陈述的证明参考其它论文。该证明的关键是一个无量词公式的无限集是不一致的当且仅当某个有限子集是不一致的。
[^10]:为了定义“字典顺序”，下标被认为是写在同一行上的（比如 f~12~（a）被视为是“f12(a)”）。那么我们的字母表由下列符号组成：( ) f 0 1 2 3 4 5 6 7 8 9 , ;（符号；是被用来隔开L-元组中的成员的，所以有 “ f2(f1)；f6( f1,f2(f1) ) ”），L-元组的“字典顺序”是指它们的排列像字典中的词的排列一样。
[^11]:如例子所示，每当一个全称量词所包含的变量被替换时，该全称量词被删除。这种“替换”在技术上称为全称实例。
